{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": ["*"],
        "": ["*"]
      }
    }
  },
  "sources": {
    "contracts/CapitalFreeLiquidateFlattened.sol": {
      "content": "// File: contracts\\interfaces\\ICapitalFreeLiquidate.sol\n\npragma solidity >=0.5.0;\n\ninterface ICapitalFreeLiquidate {\n\tfunction factory() external pure returns (address);\n\tfunction bDeployer() external pure returns (address);\n\tfunction cDeployer() external pure returns (address);\n\tfunction WETH() external pure returns (address);\n\t\n\tfunction to() external pure returns (address);\n\t\n\tfunction liquidate(\n\t\taddress uniswapV2Pair,\n\t\tuint8 toLiquidateIndex,\n\t\tuint8 takeProfitIndex,\n\t\taddress borrower,\n\t\tuint liquidateAmountMax,\n\t\tuint profitMin\n\t) external returns (uint profit);\n\t\n\tfunction skim(address token) external;\n\t\n\tfunction getBorrowable(address uniswapV2Pair, uint8 index) external view returns (address borrowable);\n\tfunction getCollateral(address uniswapV2Pair) external view returns (address collateral);\n\tfunction getLendingPool(address uniswapV2Pair) external view returns (address collateral, address borrowableA, address borrowableB);\n}\n\n// File: contracts\\interfaces\\IBorrowable.sol\n\npragma solidity >=0.5.0;\n\ninterface IBorrowable {\n\n\t/*** Impermax ERC20 ***/\n\t\n\tevent Transfer(address indexed from, address indexed to, uint value);\n\tevent Approval(address indexed owner, address indexed spender, uint value);\n\t\n\tfunction name() external pure returns (string memory);\n\tfunction symbol() external pure returns (string memory);\n\tfunction decimals() external pure returns (uint8);\n\tfunction totalSupply() external view returns (uint);\n\tfunction balanceOf(address owner) external view returns (uint);\n\tfunction allowance(address owner, address spender) external view returns (uint);\n\tfunction approve(address spender, uint value) external returns (bool);\n\tfunction transfer(address to, uint value) external returns (bool);\n\tfunction transferFrom(address from, address to, uint value) external returns (bool);\n\t\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\n\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\n\tfunction nonces(address owner) external view returns (uint);\n\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\t\n\t/*** Pool Token ***/\n\t\n\tevent Mint(address indexed sender, address indexed minter, uint mintAmount, uint mintTokens);\n\tevent Redeem(address indexed sender, address indexed redeemer, uint redeemAmount, uint redeemTokens);\n\tevent Sync(uint totalBalance);\n\t\n\tfunction underlying() external view returns (address);\n\tfunction factory() external view returns (address);\n\tfunction totalBalance() external view returns (uint);\n\tfunction MINIMUM_LIQUIDITY() external pure returns (uint);\n\n\tfunction exchangeRate() external returns (uint);\n\tfunction mint(address minter) external returns (uint mintTokens);\n\tfunction redeem(address redeemer) external returns (uint redeemAmount);\n\tfunction skim(address to) external;\n\tfunction sync() external;\n\t\n\tfunction _setFactory() external;\n\t\n\t/*** Borrowable ***/\n\n\tevent BorrowApproval(address indexed owner, address indexed spender, uint value);\n\tevent Borrow(address indexed sender, address indexed borrower, address indexed receiver, uint borrowAmount, uint repayAmount, uint accountBorrowsPrior, uint accountBorrows, uint totalBorrows);\n\tevent Liquidate(address indexed sender, address indexed borrower, address indexed liquidator, uint seizeTokens, uint repayAmount, uint accountBorrowsPrior, uint accountBorrows, uint totalBorrows);\n\t\n\tfunction BORROW_FEE() external pure returns (uint);\n\tfunction collateral() external view returns (address);\n\tfunction reserveFactor() external view returns (uint);\n\tfunction exchangeRateLast() external view returns (uint);\n\tfunction borrowIndex() external view returns (uint);\n\tfunction totalBorrows() external view returns (uint);\n\tfunction borrowAllowance(address owner, address spender) external view returns (uint);\n\tfunction borrowBalance(address borrower) external view returns (uint);\t\n\tfunction borrowTracker() external view returns (address);\n\t\n\tfunction BORROW_PERMIT_TYPEHASH() external pure returns (bytes32);\n\tfunction borrowApprove(address spender, uint256 value) external returns (bool);\n\tfunction borrowPermit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\tfunction borrow(address borrower, address receiver, uint borrowAmount, bytes calldata data) external;\n\tfunction liquidate(address borrower, address liquidator) external returns (uint seizeTokens);\n\tfunction trackBorrow(address borrower) external;\n\t\n\t/*** Borrowable Interest Rate Model ***/\n\n\tevent AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);\n\tevent CalculateKink(uint kinkRate);\n\tevent CalculateBorrowRate(uint borrowRate);\n\t\n\tfunction KINK_BORROW_RATE_MAX() external pure returns (uint);\n\tfunction KINK_BORROW_RATE_MIN() external pure returns (uint);\n\tfunction KINK_MULTIPLIER() external pure returns (uint);\n\tfunction borrowRate() external view returns (uint);\n\tfunction kinkBorrowRate() external view returns (uint);\n\tfunction kinkUtilizationRate() external view returns (uint);\n\tfunction adjustSpeed() external view returns (uint);\n\tfunction rateUpdateTimestamp() external view returns (uint32);\n\tfunction accrualTimestamp() external view returns (uint32);\n\t\n\tfunction accrueInterest() external;\n\t\n\t/*** Borrowable Setter ***/\n\n\tevent NewReserveFactor(uint newReserveFactor);\n\tevent NewKinkUtilizationRate(uint newKinkUtilizationRate);\n\tevent NewAdjustSpeed(uint newAdjustSpeed);\n\tevent NewBorrowTracker(address newBorrowTracker);\n\n\tfunction RESERVE_FACTOR_MAX() external pure returns (uint);\n\tfunction KINK_UR_MIN() external pure returns (uint);\n\tfunction KINK_UR_MAX() external pure returns (uint);\n\tfunction ADJUST_SPEED_MIN() external pure returns (uint);\n\tfunction ADJUST_SPEED_MAX() external pure returns (uint);\n\t\n\tfunction _initialize (\n\t\tstring calldata _name, \n\t\tstring calldata _symbol,\n\t\taddress _underlying, \n\t\taddress _collateral\n\t) external;\n\tfunction _setReserveFactor(uint newReserveFactor) external;\n\tfunction _setKinkUtilizationRate(uint newKinkUtilizationRate) external;\n\tfunction _setAdjustSpeed(uint newAdjustSpeed) external;\n\tfunction _setBorrowTracker(address newBorrowTracker) external;\n}\n\n// File: contracts\\interfaces\\ICollateral.sol\n\npragma solidity >=0.5.0;\n\ninterface ICollateral {\n\n\t/*** Impermax ERC20 ***/\n\t\n\tevent Transfer(address indexed from, address indexed to, uint value);\n\tevent Approval(address indexed owner, address indexed spender, uint value);\n\t\n\tfunction name() external pure returns (string memory);\n\tfunction symbol() external pure returns (string memory);\n\tfunction decimals() external pure returns (uint8);\n\tfunction totalSupply() external view returns (uint);\n\tfunction balanceOf(address owner) external view returns (uint);\n\tfunction allowance(address owner, address spender) external view returns (uint);\n\tfunction approve(address spender, uint value) external returns (bool);\n\tfunction transfer(address to, uint value) external returns (bool);\n\tfunction transferFrom(address from, address to, uint value) external returns (bool);\n\t\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\n\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\n\tfunction nonces(address owner) external view returns (uint);\n\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\t\n\t/*** Pool Token ***/\n\t\n\tevent Mint(address indexed sender, address indexed minter, uint mintAmount, uint mintTokens);\n\tevent Redeem(address indexed sender, address indexed redeemer, uint redeemAmount, uint redeemTokens);\n\tevent Sync(uint totalBalance);\n\t\n\tfunction underlying() external view returns (address);\n\tfunction factory() external view returns (address);\n\tfunction totalBalance() external view returns (uint);\n\tfunction MINIMUM_LIQUIDITY() external pure returns (uint);\n\n\tfunction exchangeRate() external returns (uint);\n\tfunction mint(address minter) external returns (uint mintTokens);\n\tfunction redeem(address redeemer) external returns (uint redeemAmount);\n\tfunction skim(address to) external;\n\tfunction sync() external;\n\t\n\tfunction _setFactory() external;\n\t\n\t/*** Collateral ***/\n\t\n\tfunction borrowable0() external view returns (address);\n\tfunction borrowable1() external view returns (address);\n\tfunction simpleUniswapOracle() external view returns (address);\n\tfunction safetyMarginSqrt() external view returns (uint);\n\tfunction liquidationIncentive() external view returns (uint);\n\t\n\tfunction getPrices() external returns (uint price0, uint price1);\n\tfunction tokensUnlocked(address from, uint value) external returns (bool);\n\tfunction accountLiquidityAmounts(address account, uint amount0, uint amount1) external returns (uint liquidity, uint shortfall);\n\tfunction accountLiquidity(address account) external returns (uint liquidity, uint shortfall);\n\tfunction canBorrow(address account, address borrowable, uint accountBorrows) external returns (bool);\n\tfunction seize(address liquidator, address borrower, uint repayAmount) external returns (uint seizeTokens);\n\tfunction flashRedeem(address redeemer, uint redeemAmount, bytes calldata data) external;\n\t\n\t/*** Collateral Setter ***/\n\t\n\tevent NewSafetyMargin(uint newSafetyMarginSqrt);\n\tevent NewLiquidationIncentive(uint newLiquidationIncentive);\n\n\tfunction SAFETY_MARGIN_SQRT_MIN() external pure returns (uint);\n\tfunction SAFETY_MARGIN_SQRT_MAX() external pure returns (uint);\n\tfunction LIQUIDATION_INCENTIVE_MIN() external pure returns (uint);\n\tfunction LIQUIDATION_INCENTIVE_MAX() external pure returns (uint);\n\t\n\tfunction _initialize (\n\t\tstring calldata _name, \n\t\tstring calldata _symbol,\n\t\taddress _underlying, \n\t\taddress _borrowable0, \n\t\taddress _borrowable1\n\t) external;\n\tfunction _setSafetyMarginSqrt(uint newSafetyMarginSqrt) external;\n\tfunction _setLiquidationIncentive(uint newLiquidationIncentive) external;\n}\n\n// File: contracts\\interfaces\\IImpermaxCallee.sol\n\npragma solidity >=0.5.0;\n\ninterface IImpermaxCallee {\n    function impermaxBorrow(address sender, address borrower, uint borrowAmount, bytes calldata data) external;\n    function impermaxRedeem(address sender, uint redeemAmount, bytes calldata data) external;\n}\n\n// File: contracts\\interfaces\\IERC20.sol\n\npragma solidity >=0.5.0;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n\n// File: contracts\\interfaces\\IWETH.sol\n\npragma solidity >=0.5.0;\n\ninterface IWETH {\n    function deposit() external payable;\n    function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint) external;\n}\n\n// File: contracts\\interfaces\\IUniswapV2Pair.sol\n\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n\n// File: contracts\\interfaces\\IStakedLPToken01.sol\n\npragma solidity >=0.5.0;\n\ninterface IStakedLPToken01 {\n\n\t/*** Impermax ERC20 ***/\n\t\n\tevent Transfer(address indexed from, address indexed to, uint value);\n\tevent Approval(address indexed owner, address indexed spender, uint value);\n\t\n\tfunction name() external pure returns (string memory);\n\tfunction symbol() external pure returns (string memory);\n\tfunction decimals() external pure returns (uint8);\n\tfunction totalSupply() external view returns (uint);\n\tfunction balanceOf(address owner) external view returns (uint);\n\tfunction allowance(address owner, address spender) external view returns (uint);\n\tfunction approve(address spender, uint value) external returns (bool);\n\tfunction transfer(address to, uint value) external returns (bool);\n\tfunction transferFrom(address from, address to, uint value) external returns (bool);\n\t\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\n\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\n\tfunction nonces(address owner) external view returns (uint);\n\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\t\n\t/*** Pool Token ***/\n\t\n\tevent Mint(address indexed sender, address indexed minter, uint mintAmount, uint mintTokens);\n\tevent Redeem(address indexed sender, address indexed redeemer, uint redeemAmount, uint redeemTokens);\n\tevent Sync(uint totalBalance);\n\t\n\tfunction underlying() external view returns (address);\n\tfunction factory() external view returns (address);\n\tfunction totalBalance() external view returns (uint);\n\tfunction MINIMUM_LIQUIDITY() external pure returns (uint);\n\n\tfunction exchangeRate() external returns (uint);\n\tfunction mint(address minter) external returns (uint mintTokens);\n\tfunction redeem(address redeemer) external returns (uint redeemAmount);\n\tfunction skim(address to) external;\n\tfunction sync() external;\n\t\n\tfunction _setFactory() external;\n\t\n\t/*** StakedLPToken ***/\n\t\n\tevent Reinvest(address indexed caller, uint256 reward, uint256 bounty);\n\t\n\tfunction isStakedLPToken() external pure returns (bool);\n\tfunction stakingRewards() external view returns (address);\n\tfunction rewardsToken() external view returns (address);\n\tfunction router() external view returns (address);\n\tfunction WETH() external view returns (address);\n\tfunction token0() external view returns (address);\n\tfunction token1() external view returns (address);\n\tfunction REINVEST_BOUNTY() external pure returns (uint256);\n\t\n\tfunction getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\tfunction price0CumulativeLast() external view returns (uint256);\n\tfunction price1CumulativeLast() external view returns (uint256);\n\n\tfunction _initialize (\n\t\taddress _stakingRewards,\n\t\taddress _underlying,\n\t\taddress _rewardsToken,\n\t\taddress _token0,\n\t\taddress _token1,\n\t\taddress _router,\n\t\taddress _WETH\n\t) external;\n\n\tfunction reinvest() external;\n}\n\n// File: contracts\\libraries\\SafeMath.sol\n\npragma solidity =0.6.6;\n\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\n// Subject to the MIT license.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction underflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: contracts\\libraries\\TransferHelper.sol\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity =0.6.6;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeApprove: approve failed'\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeTransfer: transfer failed'\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::transferFrom: transferFrom failed'\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\n    }\n}\n\n// File: contracts\\libraries\\UniswapV2Library.sol\n\npragma solidity >=0.5.0;\n\n\n\nlibrary UniswapV2Library {\n    using SafeMath for uint;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(uint(keccak256(abi.encodePacked(\n                hex'ff',\n                factory,\n                keccak256(abi.encodePacked(token0, token1)),\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n            ))));\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\n        uint denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[0] = amountIn;\n        for (uint i; i < path.length - 1; i++) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint i = path.length - 1; i > 0; i--) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}\n\n// File: contracts\\CapitalFreeLiquidate02.sol\n\npragma solidity =0.6.6;\npragma experimental ABIEncoderV2;\n\n\n\n\n\n\n\n\n\n\n\n\n// This assumes that the borrower has enough collateral to repay\n// The chance that this is not true is low and the check isn't worth the additional gas cost\n// The check should be done off chain, and the caller should use the right liquidateAmount parameter\n// Another problem is the slippage, so it may be convenient to liquidate large amounts in multiple rounds\n\n// TODO: bot to liquidate both sides at the same time?\n\ncontract CapitalFreeLiquidate02 is ICapitalFreeLiquidate, IImpermaxCallee {\n\tusing SafeMath for uint;\n\n\taddress public immutable override factory;\n\taddress public immutable override bDeployer;\n\taddress public immutable override cDeployer;\n\taddress public immutable override WETH;\n\t\n\taddress public override to;\n\n\tconstructor(address _factory, address _bDeployer, address _cDeployer, address _WETH, address _to) public {\n\t\tfactory = _factory;\n\t\tbDeployer = _bDeployer;\n\t\tcDeployer = _cDeployer;\n\t\tWETH = _WETH;\n\t\tto = _to;\n\t}\n\n\treceive() external payable {\n\t\tassert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\n\t}\n\t\n\tfunction _burn(\n\t\taddress underlying, \n\t\taddress uniswapV2Pair, \n\t\tuint collateralAmount\n\t) internal virtual returns (uint amount0, uint amount1) {\n\t\tIUniswapV2Pair(underlying).transfer(underlying, collateralAmount);\n\t\tif (isStakedLPToken(underlying)) IStakedLPToken01(underlying).redeem(uniswapV2Pair);\n\t\t(amount0, amount1) = IUniswapV2Pair(uniswapV2Pair).burn(address(this));\n\t}\n\t\n\tfunction _swap(\n\t\taddress uniswapV2Pair, \n\t\taddress tokenIn, \n\t\tuint amountIn, \n\t\tuint amountOut, \n\t\tuint8 index\n\t) internal virtual {\n\t\tTransferHelper.safeTransfer(tokenIn, uniswapV2Pair, amountIn);\n\t\t(uint amount0Out, uint amount1Out) = index == 1 ? (uint(0), amountOut) : (amountOut, uint(0));\n\t\tIUniswapV2Pair(uniswapV2Pair).swap(amount0Out, amount1Out, address(this), new bytes(0));\n\t}\n\t\n\tfunction _liquidateAmount(\n\t\taddress borrowable,\n\t\tuint amountMax,\n\t\taddress borrower\n\t) internal virtual returns (uint amount) {\n\t\tIBorrowable(borrowable).accrueInterest();\n\t\tuint borrowedAmount = IBorrowable(borrowable).borrowBalance(borrower);\n\t\tamount = amountMax < borrowedAmount ? amountMax : borrowedAmount;\n\t}\n\t\n\tfunction _getBorrowablePrice(\n\t\taddress underlying,\n\t\taddress collateral,\n\t\tuint8 index,\n\t\tuint swapAmount\n\t) internal virtual returns (uint price) {\n\t\t(uint price0, uint price1) = ICollateral(collateral).getPrices();\n\t\tprice = index == 0 ? price0 : price1;\n\t\taddress uniswapV2Pair = getUniswapV2Pair(underlying);\n\t\t(uint reserve0, uint reserve1,) = IUniswapV2Pair(uniswapV2Pair).getReserves();\n\t\tuint reserve = index == 0 ? reserve0 : reserve1;\n\t\t// Account for LP appreciation after swap\n\t\tprice = price.mul(reserve).div(reserve.add(swapAmount * 3 / 1000));\n\t}\n\t\n\tfunction _getExpectedCollateralAmount(\n\t\taddress underlying,\n\t\taddress collateral,\n\t\tuint8 toLiquidateIndex,\n\t\tuint liquidateAmount\n\t) internal virtual returns (uint collateralAmount) {\n\t\tuint price = _getBorrowablePrice(underlying, collateral, toLiquidateIndex, liquidateAmount);\n\t\tuint liquidationIncentive = ICollateral(collateral).liquidationIncentive();\n\t\tcollateralAmount = liquidateAmount.mul(liquidationIncentive).div(1e18).mul(price).div(1e18).sub(1, \"CapitalFreeLiquidate: ZERO_COLLATERAL_AMOUNT (frontrun)\");\n\t}\n\t\n\tfunction _simulateBurn(\n\t\taddress underlying,\n\t\tuint collateralAmount\n\t) internal virtual view returns (uint amount0, uint amount1, uint reserve0, uint reserve1) {\n\t\taddress uniswapV2Pair = getUniswapV2Pair(underlying);\n\t\tuint totalSupply = IUniswapV2Pair(uniswapV2Pair).totalSupply();\n\t\t(uint reserve0Old, uint reserve1Old,) = IUniswapV2Pair(uniswapV2Pair).getReserves();\n\t\tamount0 = collateralAmount.mul(reserve0Old).div(totalSupply);\n\t\tamount1 = collateralAmount.mul(reserve1Old).div(totalSupply);\n\t\treserve0 = reserve0Old.sub(amount0, \"CapitalFreeLiquidate: NEGATIVE_RESERVE_0\");\n\t\treserve1 = reserve1Old.sub(amount1, \"CapitalFreeLiquidate: NEGATIVE_RESERVE_1\");\n\t}\n\n\tfunction _getLiquidateProfit(\n\t\taddress underlying,\n\t\tuint8 toLiquidateIndex,\n\t\tuint8 takeProfitIndex,\n\t\tuint liquidateAmount,\n\t\tuint collateralAmount\n\t) internal virtual view returns (uint profit, uint amountIn, uint amountOut) {\n\t\t(uint amount0, uint amount1, uint reserve0, uint reserve1) = _simulateBurn(underlying, collateralAmount);\n\t\t(uint reserveIn, uint reserveOut) = toLiquidateIndex == 1 ? (reserve0, reserve1) : (reserve1, reserve0);\n\t\tuint amountOutBalance = toLiquidateIndex == 1 ? amount1 : amount0;\n\t\tif (takeProfitIndex == toLiquidateIndex) {\n\t\t\t// Swap all\n\t\t\tamountIn = toLiquidateIndex == 1 ? amount0 : amount1;\n\t\t\tamountOut = UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\n\t\t\tprofit = amountOutBalance.add(amountOut).sub(liquidateAmount, \"CapitalFreeLiquidate: NEGATIVE_PROFIT_1\");\n\t\t}\n\t\telse {\n\t\t\t// Swap only necessary\n\t\t\tamountOut = liquidateAmount.sub(amountOutBalance, \"CapitalFreeLiquidate: NEGATIVE_AMOUNT_OUT\");\n\t\t\tamountIn = UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\n\t\t\tuint amountInBalance = toLiquidateIndex == 1 ? amount0 : amount1;\n\t\t\tprofit = amountInBalance.sub(amountIn, \"CapitalFreeLiquidate: NEGATIVE_PROFIT_2\");\n\t\t}\n\t}\n\t\n\tfunction _getTokenInTokenOut(\n\t\taddress underlying,\n\t\tuint8 index\n\t) internal virtual view returns (address tokenIn, address tokenOut) {\n\t\taddress token0 = IUniswapV2Pair(underlying).token0();\n\t\taddress token1 = IUniswapV2Pair(underlying).token1();\n\t\t(tokenIn, tokenOut) = index == 1 ? (token0, token1) : (token1, token0);\n\t}\n\t\n\tfunction liquidate(\n\t\taddress underlying,\n\t\tuint8 toLiquidateIndex,\n\t\tuint8 takeProfitIndex,\n\t\taddress borrower,\n\t\tuint liquidateAmountMax,\n\t\tuint profitMin\n\t) external virtual override returns (uint profit) {\n\t\taddress collateral = getCollateral(underlying);\t\t\n\t\taddress borrowable = getBorrowable(underlying, toLiquidateIndex);\n\t\tuint liquidateAmount = _liquidateAmount(borrowable, liquidateAmountMax, borrower);\n\t\tuint collateralAmount = _getExpectedCollateralAmount(underlying, collateral, toLiquidateIndex, liquidateAmount);\n\t\tuint amountIn;\n\t\tuint amountOut;\n\t\t(profit, amountIn, amountOut) = \n\t\t\t_getLiquidateProfit(underlying, toLiquidateIndex, takeProfitIndex, liquidateAmount, collateralAmount);\n\t\trequire(profit >= profitMin, \"CapitalFreeLiquidator: INSUFFICIENT_PROFIT\");\n\t\tbytes memory data = abi.encode(CalleeData({\n\t\t\tunderlying: underlying,\n\t\t\tcollateral: collateral,\n\t\t\tborrowable: borrowable,\n\t\t\ttoLiquidateIndex: toLiquidateIndex,\n\t\t\ttakeProfitIndex: takeProfitIndex,\n\t\t\tborrower: borrower,\n\t\t\tamountIn: amountIn,\n\t\t\tamountOut: amountOut,\n\t\t\tliquidateAmount: liquidateAmount\n\t\t}));\n\t\tICollateral(collateral).flashRedeem(address(this), collateralAmount, data);\n\t}\n\t\n\tfunction liquidateCallback(\n\t\taddress underlying,\n\t\taddress collateral,\n\t\taddress borrowable,\n\t\tuint8 toLiquidateIndex,\n\t\tuint8 takeProfitIndex,\n\t\taddress borrower,\n\t\tuint amountIn,\n\t\tuint amountOut,\n\t\tuint liquidateAmount,\n\t\tuint collateralAmount\n\t) internal virtual {\n\t\taddress uniswapV2Pair = getUniswapV2Pair(underlying);\n\t\t_burn(underlying, uniswapV2Pair, collateralAmount);\n\t\t(address tokenIn, address tokenOut) = _getTokenInTokenOut(underlying, toLiquidateIndex);\n\t\t_swap(uniswapV2Pair, tokenIn, amountIn, amountOut, toLiquidateIndex);\n\t\tTransferHelper.safeTransfer(tokenOut, borrowable, liquidateAmount);\n\t\tuint seizeTokens = IBorrowable(borrowable).liquidate(borrower, address(this));\n\t\tTransferHelper.safeTransfer(collateral, collateral, seizeTokens);\n\t\tif (toLiquidateIndex == takeProfitIndex) skim(tokenOut);\n\t\telse skim(tokenIn);\n\t}\n\t\n\tstruct CalleeData {\n\t\taddress underlying;\n\t\taddress collateral;\n\t\taddress borrowable;\n\t\tuint8 toLiquidateIndex;\n\t\tuint8 takeProfitIndex;\n\t\taddress borrower;\n\t\tuint amountIn;\n\t\tuint amountOut;\n\t\tuint liquidateAmount;\n\t}\n\t\n\tfunction impermaxRedeem(address sender, uint redeemAmount, bytes calldata data) external virtual override {\n\t\tsender;\n\t\t// no security check needed\n\t\tCalleeData memory calleeData = abi.decode(data, (CalleeData));\n\t\tliquidateCallback(\n\t\t\tcalleeData.underlying,\n\t\t\tcalleeData.collateral,\n\t\t\tcalleeData.borrowable,\n\t\t\tcalleeData.toLiquidateIndex,\n\t\t\tcalleeData.takeProfitIndex,\n\t\t\tcalleeData.borrower,\n\t\t\tcalleeData.amountIn,\n\t\t\tcalleeData.amountOut,\n\t\t\tcalleeData.liquidateAmount,\n\t\t\tredeemAmount\n\t\t);\n\t}\n\n\tfunction impermaxBorrow(address sender, address borrower, uint borrowAmount, bytes calldata data) external virtual override { sender; borrower; borrowAmount; data; }\n\t\n\tfunction skim(address token) public virtual override {\n\t\tuint balance = IERC20(token).balanceOf(address(this));\n\t\tif (token == WETH) {\t\t\n\t\t\tIWETH(WETH).withdraw(balance);\n\t\t\tTransferHelper.safeTransferETH(to, balance);\n\t\t}\n\t\telse TransferHelper.safeTransfer(token, to, balance);\n\t}\n\t\n\t/*** UTILITIES ***/\n\t\n\tfunction isStakedLPToken(address underlying) public virtual view returns(bool) {\n\t\ttry IStakedLPToken01(underlying).isStakedLPToken() returns (bool result) {\n\t\t\treturn result;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}\n\tfunction getUniswapV2Pair(address underlying) public virtual view returns (address) {\n\t\ttry IStakedLPToken01(underlying).underlying() returns (address u) {\n\t\t\tif (u != address(0)) return u;\n\t\t\treturn underlying;\n\t\t} catch {\n\t\t\treturn underlying;\n\t\t}\n\t}\n\t\n\tfunction getBorrowable(address underlying, uint8 index) public virtual override view returns (address borrowable) {\n\t\trequire(index < 2, \"CapitalFreeLiquidator: INDEX_TOO_HIGH\");\n\t\tborrowable = address(uint(keccak256(abi.encodePacked(\n\t\t\thex\"ff\",\n\t\t\tbDeployer,\n\t\t\tkeccak256(abi.encodePacked(factory, underlying, index)),\n\t\t\thex\"605ba1db56496978613939baf0ae31dccceea3f5ca53dfaa76512bc880d7bb8f\" // Borrowable bytecode keccak256\n\t\t))));\n\t}\n\tfunction getCollateral(address underlying) public virtual override view returns (address collateral) {\n\t\tcollateral = address(uint(keccak256(abi.encodePacked(\n\t\t\thex\"ff\",\n\t\t\tcDeployer,\n\t\t\tkeccak256(abi.encodePacked(factory, underlying)),\n\t\t\thex\"4b8788d8761647e6330407671d3c6c80afaed3d047800dba0e0e3befde047767\" // Collateral bytecode keccak256\n\t\t))));\n\t}\n\tfunction getLendingPool(address underlying) public virtual override view returns (address collateral, address borrowableA, address borrowableB) {\n\t\tcollateral = getCollateral(underlying);\n\t\tborrowableA = getBorrowable(underlying, 0);\n\t\tborrowableB = getBorrowable(underlying, 1);\n\t}\n}\n"
    }
  }
}
