import { InputTypeMap, Narrow, TypeMapper } from './types';
/**
 * Encode the data with the provided types.
 *
 * @param types The types to encode.
 * @param values The values to encode. This array must have the same length as the types array.
 * @return The ABI encoded buffer.
 */
export declare const encode: <T extends string[]>(types: import("./types").Try<T, [], (T extends [] ? [] : never) | (T extends import("./types").Narrowable ? T : never) | { [K in keyof T]: T[K] extends Function ? T[K] : (T[K] extends [] ? [] : never) | (T[K] extends import("./types").Narrowable ? T[K] : never) | { [K_1 in keyof T[K]]: T[K][K_1] extends Function ? T[K][K_1] : (T[K][K_1] extends [] ? [] : never) | (T[K][K_1] extends import("./types").Narrowable ? T[K][K_1] : never) | { [K_2 in keyof T[K][K_1]]: T[K][K_1][K_2] extends Function ? T[K][K_1][K_2] : (T[K][K_1][K_2] extends [] ? [] : never) | (T[K][K_1][K_2] extends import("./types").Narrowable ? T[K][K_1][K_2] : never) | { [K_3 in keyof T[K][K_1][K_2]]: T[K][K_1][K_2][K_3] extends Function ? T[K][K_1][K_2][K_3] : (T[K][K_1][K_2][K_3] extends [] ? [] : never) | (T[K][K_1][K_2][K_3] extends import("./types").Narrowable ? T[K][K_1][K_2][K_3] : never) | { [K_4 in keyof T[K][K_1][K_2][K_3]]: T[K][K_1][K_2][K_3][K_4] extends Function ? T[K][K_1][K_2][K_3][K_4] : (T[K][K_1][K_2][K_3][K_4] extends [] ? [] : never) | (T[K][K_1][K_2][K_3][K_4] extends import("./types").Narrowable ? T[K][K_1][K_2][K_3][K_4] : never) | { [K_5 in keyof T[K][K_1][K_2][K_3][K_4]]: T[K][K_1][K_2][K_3][K_4][K_5] extends Function ? T[K][K_1][K_2][K_3][K_4][K_5] : (T[K][K_1][K_2][K_3][K_4][K_5] extends [] ? [] : never) | (T[K][K_1][K_2][K_3][K_4][K_5] extends import("./types").Narrowable ? T[K][K_1][K_2][K_3][K_4][K_5] : never) | { [K_6 in keyof T[K][K_1][K_2][K_3][K_4][K_5]]: T[K][K_1][K_2][K_3][K_4][K_5][K_6] extends Function ? T[K][K_1][K_2][K_3][K_4][K_5][K_6] : (T[K][K_1][K_2][K_3][K_4][K_5][K_6] extends [] ? [] : never) | (T[K][K_1][K_2][K_3][K_4][K_5][K_6] extends import("./types").Narrowable ? T[K][K_1][K_2][K_3][K_4][K_5][K_6] : never) | { [K_7 in keyof T[K][K_1][K_2][K_3][K_4][K_5][K_6]]: T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7] extends Function ? T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7] : (T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7] extends [] ? [] : never) | (T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7] extends import("./types").Narrowable ? T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7] : never) | { [K_8 in keyof T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7]]: T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8] extends Function ? T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8] : (T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8] extends [] ? [] : never) | (T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8] extends import("./types").Narrowable ? T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8] : never) | { [K_9 in keyof T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8]]: T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8][K_9] extends Function ? T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8][K_9] : (T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8][K_9] extends [] ? [] : never) | (T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8][K_9] extends import("./types").Narrowable ? T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8][K_9] : never) | { [K_10 in keyof T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8][K_9]]: T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8][K_9][K_10] extends Function ? T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8][K_9][K_10] : (T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8][K_9][K_10] extends [] ? [] : never) | (T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8][K_9][K_10] extends import("./types").Narrowable ? T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8][K_9][K_10] : never) | any; }; }; }; }; }; }; }; }; }; }; }>, values: { [K_11 in keyof T]: T[K_11] extends T[number] ? InputTypeMap[T[K_11]] : unknown; }) => Uint8Array;
/**
 * Decode an ABI encoded buffer with the specified types.
 *
 * @param types The types to decode the buffer with.
 * @param buffer The buffer to decode.
 * @return The decoded values as array.
 */
export declare const decode: <T extends string[]>(types: import("./types").Try<T, [], (T extends [] ? [] : never) | (T extends import("./types").Narrowable ? T : never) | { [K in keyof T]: T[K] extends Function ? T[K] : (T[K] extends [] ? [] : never) | (T[K] extends import("./types").Narrowable ? T[K] : never) | { [K_1 in keyof T[K]]: T[K][K_1] extends Function ? T[K][K_1] : (T[K][K_1] extends [] ? [] : never) | (T[K][K_1] extends import("./types").Narrowable ? T[K][K_1] : never) | { [K_2 in keyof T[K][K_1]]: T[K][K_1][K_2] extends Function ? T[K][K_1][K_2] : (T[K][K_1][K_2] extends [] ? [] : never) | (T[K][K_1][K_2] extends import("./types").Narrowable ? T[K][K_1][K_2] : never) | { [K_3 in keyof T[K][K_1][K_2]]: T[K][K_1][K_2][K_3] extends Function ? T[K][K_1][K_2][K_3] : (T[K][K_1][K_2][K_3] extends [] ? [] : never) | (T[K][K_1][K_2][K_3] extends import("./types").Narrowable ? T[K][K_1][K_2][K_3] : never) | { [K_4 in keyof T[K][K_1][K_2][K_3]]: T[K][K_1][K_2][K_3][K_4] extends Function ? T[K][K_1][K_2][K_3][K_4] : (T[K][K_1][K_2][K_3][K_4] extends [] ? [] : never) | (T[K][K_1][K_2][K_3][K_4] extends import("./types").Narrowable ? T[K][K_1][K_2][K_3][K_4] : never) | { [K_5 in keyof T[K][K_1][K_2][K_3][K_4]]: T[K][K_1][K_2][K_3][K_4][K_5] extends Function ? T[K][K_1][K_2][K_3][K_4][K_5] : (T[K][K_1][K_2][K_3][K_4][K_5] extends [] ? [] : never) | (T[K][K_1][K_2][K_3][K_4][K_5] extends import("./types").Narrowable ? T[K][K_1][K_2][K_3][K_4][K_5] : never) | { [K_6 in keyof T[K][K_1][K_2][K_3][K_4][K_5]]: T[K][K_1][K_2][K_3][K_4][K_5][K_6] extends Function ? T[K][K_1][K_2][K_3][K_4][K_5][K_6] : (T[K][K_1][K_2][K_3][K_4][K_5][K_6] extends [] ? [] : never) | (T[K][K_1][K_2][K_3][K_4][K_5][K_6] extends import("./types").Narrowable ? T[K][K_1][K_2][K_3][K_4][K_5][K_6] : never) | { [K_7 in keyof T[K][K_1][K_2][K_3][K_4][K_5][K_6]]: T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7] extends Function ? T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7] : (T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7] extends [] ? [] : never) | (T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7] extends import("./types").Narrowable ? T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7] : never) | { [K_8 in keyof T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7]]: T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8] extends Function ? T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8] : (T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8] extends [] ? [] : never) | (T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8] extends import("./types").Narrowable ? T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8] : never) | { [K_9 in keyof T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8]]: T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8][K_9] extends Function ? T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8][K_9] : (T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8][K_9] extends [] ? [] : never) | (T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8][K_9] extends import("./types").Narrowable ? T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8][K_9] : never) | { [K_10 in keyof T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8][K_9]]: T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8][K_9][K_10] extends Function ? T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8][K_9][K_10] : (T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8][K_9][K_10] extends [] ? [] : never) | (T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8][K_9][K_10] extends import("./types").Narrowable ? T[K][K_1][K_2][K_3][K_4][K_5][K_6][K_7][K_8][K_9][K_10] : never) | any; }; }; }; }; }; }; }; }; }; }; }>, buffer: Uint8Array) => { [K_11 in keyof T]: T[K_11] extends T[number] ? import("./types").OutputTypeMap[T[K_11]] : unknown; };
