{"version":3,"sources":["../../../src/utils/buffer.ts"],"names":["BUFFER_WIDTH","HEX_REGEX","stripPrefix","value","startsWith","substring","getTextEncoder","TextEncoder","Encoder","require","getTextDecoder","encoding","Decoder","TextDecoder","toUtf8","data","decode","fromUtf8","encode","toHex","Array","from","map","n","toString","slice","join","fromHex","length","Error","match","Uint8Array","byte","parseInt","toBuffer","string","padStart","concat","buffers","reduce","a","b","buffer","set","addPadding","padding","Math","max","fill","toNumber","hex","BigInt"],"mappings":"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","sourcesContent":["const BUFFER_WIDTH = 32;\nconst HEX_REGEX = /^[a-f0-9]+$/i;\n\nexport type BinaryLike = string | number | bigint | ArrayBufferLike | number[];\n\nexport const stripPrefix = (value: string): string => {\n  if (value.startsWith('0x')) {\n    return value.substring(2);\n  }\n\n  return value;\n};\n\n/**\n * Returns an instance of `TextEncoder` that works with both Node.js and web browsers.\n */\nexport const getTextEncoder = (): TextEncoder => {\n  if (typeof TextEncoder === 'undefined') {\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const Encoder = require('util').TextEncoder;\n    return new Encoder();\n  }\n\n  return new TextEncoder();\n};\n\n/**\n * Returns an instance of `TextDecoder` that works with both Node.js and web browsers.\n */\nexport const getTextDecoder = (encoding = 'utf8'): TextDecoder => {\n  if (typeof TextEncoder === 'undefined') {\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const Decoder = require('util').TextDecoder;\n    return new Decoder(encoding);\n  }\n\n  return new TextDecoder(encoding);\n};\n\n/**\n * Get a buffer as UTF-8 encoded string.\n *\n * @param data The buffer to convert to UTF-8.\n * @return The buffer as UTF-8 encoded string.\n */\nexport const toUtf8 = (data: Uint8Array): string => {\n  return getTextDecoder().decode(data);\n};\n\n/**\n * Get a UTF-8 encoded string as buffer.\n *\n * @param data The string to convert to a buffer.\n * @return The buffer.\n */\nexport const fromUtf8 = (data: string): Uint8Array => {\n  return getTextEncoder().encode(data);\n};\n\n/**\n * Get a Uint8Array as hexadecimal string.\n *\n * @param data The buffer to convert to a hexadecimal string.\n * @return The buffer as hexadecimal string.\n */\nexport const toHex = (data: Uint8Array): string => {\n  return Array.from(data)\n    .map((n) => `0${n.toString(16)}`.slice(-2))\n    .join('');\n};\n\n/**\n * Get a hexadecimal string as Uint8Array.\n *\n * @param data The hexadecimal string to convert to a buffer.\n * @return The buffer.\n */\nexport const fromHex = (data: string): Uint8Array => {\n  if (data.startsWith('0x')) {\n    data = data.slice(2);\n  }\n\n  if (data.length % 2 !== 0) {\n    throw new Error('Length must be even');\n  }\n\n  if (!data.match(HEX_REGEX)) {\n    throw new Error('Input must be hexadecimal');\n  }\n\n  return new Uint8Array(data.match(/.{1,2}/g)!.map((byte) => parseInt(byte, 16)));\n};\n\n/**\n * Attempt to parse a value as Uint8Array. If `data` is a number, this will pad the buffer to 32 bytes.\n *\n * @param data The value to parse as Uint8Array.\n * @return The resulting Uint8Array.\n */\nexport const toBuffer = (data: BinaryLike): Uint8Array => {\n  if (typeof data === 'string') {\n    return fromHex(data);\n  }\n\n  if (typeof data === 'number' || typeof data === 'bigint') {\n    const string = data.toString(16);\n    return fromHex(string.padStart(BUFFER_WIDTH * 2, '0'));\n  }\n\n  return new Uint8Array(data);\n};\n\n/**\n * Safe function to merge multiple Uint8Arrays into a single Uint8array. This works with buffers of any size.\n *\n * @param buffers The buffers to combine.\n * @return The combined buffers.\n */\nexport const concat = (buffers: Uint8Array[]): Uint8Array => {\n  return buffers.reduce((a, b) => {\n    const buffer = new Uint8Array(a.length + b.length);\n    buffer.set(a);\n    buffer.set(b, a.length);\n\n    return buffer;\n  }, new Uint8Array(0));\n};\n\n/**\n * Add padding to a buffer. If the buffer is larger than `length`, this function won't do anything. If it's smaller, the\n * buffer will be padded to the specified length, with extra zeroes at the end.\n *\n * @param buffer The buffer to add padding to.\n * @param [length] The number of bytes to pad the buffer to.\n * @return The padded buffer.\n */\nexport const addPadding = (buffer: Uint8Array, length = BUFFER_WIDTH): Uint8Array => {\n  const padding = new Uint8Array(Math.max(length - buffer.length, 0)).fill(0x00);\n  return concat([buffer, padding]);\n};\n\n/**\n * Get a number from a buffer. Returns zero if the buffer is empty.\n *\n * @param buffer The buffer to get a number for.\n * @return The parsed number.\n */\nexport const toNumber = (buffer: Uint8Array): bigint => {\n  const hex = toHex(buffer);\n  if (hex.length === 0) {\n    return BigInt(0);\n  }\n\n  return BigInt(`0x${hex}`);\n};\n"],"file":"buffer.js"}