{"version":3,"sources":["../../src/iterator.ts"],"names":["iterate","buffer","size","pointer","length","skip","Error","value","subarray","undefined","Uint8Array"],"mappings":";;;;;;;AAcO,MAAMA,OAAO,GAAG,WACrBC,MADqB,EAErBC,IAAI,GAAG,EAFc,EAGmC;AACxD,OAAK,IAAIC,OAAO,GAAG,CAAnB,EAAsBA,OAAO,GAAGF,MAAM,CAACG,MAAvC,EAA+CD,OAAO,IAAID,IAA1D,EAAgE;AAC9D,UAAMG,IAAI,GAAID,MAAD,IAAoB;AAC/B,UAAIA,MAAM,GAAGF,IAAT,KAAkB,CAAtB,EAAyB;AACvB,cAAM,IAAII,KAAJ,CAAU,kCAAV,CAAN;AACD;;AAEDH,MAAAA,OAAO,IAAIC,MAAX;AACD,KAND;;AAQA,UAAMG,KAAK,GAAGN,MAAM,CAACO,QAAP,CAAgBL,OAAhB,CAAd;AAEA,UAAM;AAAEE,MAAAA,IAAF;AAAQE,MAAAA;AAAR,KAAN;AACD;;AAED,SAAO;AACLF,IAAAA,IAAI,EAAE,MAAMI,SADP;AAELF,IAAAA,KAAK,EAAE,IAAIG,UAAJ;AAFF,GAAP;AAID,CAtBM","sourcesContent":["interface IteratorValue {\n  skip(length: number): void;\n  value: Uint8Array;\n}\n\n/**\n * Iterate over a buffer with the specified size. This will yield a part of the buffer starting at an increment of the\n * specified size, until the end of the buffer is reached.\n *\n * Calling the `skip` function will make it skip the specified number of bytes.\n *\n * @param buffer The buffer to iterate over.\n * @param [size] The number of bytes to iterate with.\n */\nexport const iterate = function* (\n  buffer: Uint8Array,\n  size = 32\n): Generator<IteratorValue, IteratorValue, IteratorValue> {\n  for (let pointer = 0; pointer < buffer.length; pointer += size) {\n    const skip = (length: number) => {\n      if (length % size !== 0) {\n        throw new Error('Length must be divisible by size');\n      }\n\n      pointer += length;\n    };\n\n    const value = buffer.subarray(pointer);\n\n    yield { skip, value };\n  }\n\n  return {\n    skip: () => undefined,\n    value: new Uint8Array()\n  };\n};\n"],"file":"iterator.js"}