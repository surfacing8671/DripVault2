{"version":3,"sources":["../../../src/parsers/number.ts"],"names":["NUMBER_REGEX","isSigned","type","startsWith","asNumber","value","BigInt","number","isDynamic","isType","test","encode","buffer","decode","slice"],"mappings":";;;;;;;AACA;;AAEA,MAAMA,YAAY,GAAG,kBAArB;;AAQO,MAAMC,QAAQ,GAAIC,IAAD,IAA2B;AACjD,SAAO,CAACA,IAAI,CAACC,UAAL,CAAgB,GAAhB,CAAR;AACD,CAFM;;;;AAUA,MAAMC,QAAQ,GAAIC,KAAD,IAA+B;AACrD,MAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC7B,WAAOA,KAAP;AACD;;AAED,SAAOC,MAAM,CAACD,KAAD,CAAb;AACD,CANM;;;AAQA,MAAME,MAAkC,GAAG;AAChDC,EAAAA,SAAS,EAAE,KADqC;;AAQhDC,EAAAA,MAAM,CAACP,IAAD,EAAwB;AAC5B,WAAOF,YAAY,CAACU,IAAb,CAAkBR,IAAlB,CAAP;AACD,GAV+C;;AAYhDS,EAAAA,MAAM,CAAC;AAAET,IAAAA,IAAF;AAAQU,IAAAA,MAAR;AAAgBP,IAAAA;AAAhB,GAAD,EAAsC;AAC1C,UAAME,MAAM,GAAGH,QAAQ,CAACC,KAAD,CAAvB;;AAEA,QAAIJ,QAAQ,CAACC,IAAD,CAAZ,EAAoB;AAClB,aAAO,mBAAO,CAACU,MAAD,EAAS,6BAAiBL,MAAjB,EAAyB,EAAzB,CAAT,CAAP,CAAP;AACD;;AAED,WAAO,mBAAO,CAACK,MAAD,EAAS,qBAASL,MAAT,CAAT,CAAP,CAAP;AACD,GApB+C;;AAsBhDM,EAAAA,MAAM,CAAC;AAAEX,IAAAA,IAAF;AAAQG,IAAAA;AAAR,GAAD,EAAsC;AAC1C,UAAMO,MAAM,GAAGP,KAAK,CAACS,KAAN,CAAY,CAAZ,EAAe,EAAf,CAAf;;AACA,QAAIb,QAAQ,CAACC,IAAD,CAAZ,EAAoB;AAClB,aAAO,+BAAmBU,MAAnB,CAAP;AACD;;AAED,WAAO,qBAASA,MAAT,CAAP;AACD;;AA7B+C,CAA3C","sourcesContent":["import { DecodeArgs, NumberLike, Parser } from '../types';\nimport { concat, fromTwosComplement, toBuffer, toNumber, toTwosComplement } from '../utils';\n\nconst NUMBER_REGEX = /^u?int([0-9]*)?$/;\n\n/**\n * Check if a number type is signed.\n *\n * @param type The type to check.\n * @return Whether the type is signed.\n */\nexport const isSigned = (type: string): boolean => {\n  return !type.startsWith('u');\n};\n\n/**\n * Get a number-like value as bigint.\n *\n * @param value The number-like value to parse.\n * @return The value parsed as bigint.\n */\nexport const asNumber = (value: NumberLike): bigint => {\n  if (typeof value === 'bigint') {\n    return value;\n  }\n\n  return BigInt(value);\n};\n\nexport const number: Parser<NumberLike, bigint> = {\n  isDynamic: false,\n\n  /**\n   * Check if a type is a number type.\n   *\n   * @return Whether the type is a number type.\n   */\n  isType(type: string): boolean {\n    return NUMBER_REGEX.test(type);\n  },\n\n  encode({ type, buffer, value }): Uint8Array {\n    const number = asNumber(value);\n\n    if (isSigned(type)) {\n      return concat([buffer, toTwosComplement(number, 32)]);\n    }\n\n    return concat([buffer, toBuffer(number)]);\n  },\n\n  decode({ type, value }: DecodeArgs): bigint {\n    const buffer = value.slice(0, 32);\n    if (isSigned(type)) {\n      return fromTwosComplement(buffer);\n    }\n\n    return toNumber(buffer);\n  }\n};\n"],"file":"number.js"}