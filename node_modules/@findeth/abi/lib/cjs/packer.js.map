{"version":3,"sources":["../../src/packer.ts"],"names":["getParser","type","parsers","address","array","bool","bytes","fixedBytes","function","fn","number","string","tuple","parser","Object","values","find","isType","Error","isDynamicParser","isDynamic","pack","types","buffer","Uint8Array","length","staticBuffer","dynamicBuffer","functions","reduce","index","value","encode","offset","staticOffset","newStaticBuffer","fill","newDynamicBuffer","oldBuffer","subarray","updatedBuffer","target","update","unpack","iterator","map","skip","done","next","pointer","Number","decode"],"mappings":"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","sourcesContent":["import { iterate } from './iterator';\nimport { address, array, bool, bytes, fixedBytes, fn, number, string, tuple } from './parsers';\nimport { Parser } from './types';\nimport { concat, toBuffer, toNumber } from './utils';\n\n/**\n * Get the parser for the specified type. This will throw if there is no parser for the specified type.\n *\n * @param type The type to get a parser for.\n * @return The parser.\n */\nexport const getParser = (type: string): Parser => {\n  const parsers: { [key: string]: Parser } = {\n    address,\n    array,\n    bool,\n    bytes,\n    fixedBytes,\n    function: fn,\n    number,\n    string,\n    tuple\n  };\n\n  if (parsers[type]) {\n    return parsers[type];\n  }\n\n  const parser = Object.values(parsers).find((parser) => parser.isType?.(type));\n  if (parser) {\n    return parser;\n  }\n\n  throw new Error(`Type \"${type}\" is not supported`);\n};\n\n/**\n * Check if the specified parser is dynamic, for the provided types. This is primarily used for parsing tuples, where\n * a tuple can be dynamic based on the types. For other parsers, it will simply use the set `isDynamic` value.\n *\n * @param parser The parser to check.\n * @param type The type to check the parser with.\n * @return Whether the parser is dynamic.\n */\nexport const isDynamicParser = (parser: Parser, type: string): boolean => {\n  const isDynamic = parser.isDynamic;\n  if (typeof isDynamic === 'function') {\n    return isDynamic(type);\n  }\n\n  return isDynamic;\n};\n\ntype UpdateFunction = (buffer: Uint8Array) => Uint8Array;\n\ninterface PackState {\n  staticBuffer: Uint8Array;\n  dynamicBuffer: Uint8Array;\n  functions: UpdateFunction[];\n}\n\n/**\n * Pack the provided values in a buffer, encoded with the specified types. If a buffer is specified, the resulting value\n * will be concatenated with the buffer.\n *\n * @param types The types to use for encoding.\n * @param values The values to encode.\n * @param [buffer] The buffer to concatenate with.\n * @return The resulting encoded buffer.\n */\nexport const pack = (types: string[], values: unknown[], buffer: Uint8Array = new Uint8Array()): Uint8Array => {\n  if (types.length !== values.length) {\n    throw new Error('The length of the types and values must be equal');\n  }\n\n  const { staticBuffer, dynamicBuffer, functions } = types.reduce<PackState>(\n    ({ staticBuffer, dynamicBuffer, functions }, type, index) => {\n      const parser = getParser(type);\n      const value = values[index];\n\n      if (!isDynamicParser(parser, type)) {\n        return {\n          staticBuffer: parser.encode({ buffer: staticBuffer, value, type }),\n          dynamicBuffer,\n          functions\n        };\n      }\n\n      const offset = dynamicBuffer.length;\n      const staticOffset = staticBuffer.length;\n\n      const newStaticBuffer = concat([staticBuffer, new Uint8Array(32).fill(0)]);\n      const newDynamicBuffer = parser.encode({ buffer: dynamicBuffer, value, type });\n\n      const fn = (oldBuffer: Uint8Array): Uint8Array => {\n        return concat([\n          oldBuffer.subarray(0, staticOffset),\n          toBuffer(oldBuffer.length + offset),\n          oldBuffer.subarray(staticOffset + 32)\n        ]);\n      };\n\n      return {\n        staticBuffer: newStaticBuffer,\n        dynamicBuffer: newDynamicBuffer,\n        functions: [...functions, fn]\n      };\n    },\n    { staticBuffer: new Uint8Array(), dynamicBuffer: new Uint8Array(), functions: [] }\n  );\n\n  const updatedBuffer = functions.reduce<Uint8Array>((target, update) => update(target), staticBuffer);\n\n  return concat([buffer, updatedBuffer, dynamicBuffer]);\n};\n\nexport const unpack = (types: string[], buffer: Uint8Array): unknown[] => {\n  const iterator = iterate(buffer);\n\n  return types.map((type) => {\n    const {\n      value: { value, skip },\n      done\n    } = iterator.next();\n    if (done) {\n      throw new Error('Element is out of range');\n    }\n\n    const parser = getParser(type);\n    const isDynamic = isDynamicParser(parser, type);\n\n    if (isDynamic) {\n      const pointer = Number(toNumber(value.subarray(0, 32)));\n      const target = buffer.subarray(pointer);\n\n      return parser.decode({ type, value: target, skip });\n    }\n\n    return parser.decode({ type, value, skip });\n  });\n};\n"],"file":"packer.js"}