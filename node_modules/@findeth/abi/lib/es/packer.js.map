{"version":3,"sources":["../../src/packer.ts"],"names":["iterate","address","array","bool","bytes","fixedBytes","fn","number","string","tuple","concat","toBuffer","toNumber","getParser","type","parsers","function","parser","Object","values","find","isType","Error","isDynamicParser","isDynamic","pack","types","buffer","Uint8Array","length","staticBuffer","dynamicBuffer","functions","reduce","index","value","encode","offset","staticOffset","newStaticBuffer","fill","newDynamicBuffer","oldBuffer","subarray","updatedBuffer","target","update","unpack","iterator","map","skip","done","next","pointer","Number","decode"],"mappings":"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","sourcesContent":["import { iterate } from './iterator';\nimport { address, array, bool, bytes, fixedBytes, fn, number, string, tuple } from './parsers';\nimport { Parser } from './types';\nimport { concat, toBuffer, toNumber } from './utils';\n\n/**\n * Get the parser for the specified type. This will throw if there is no parser for the specified type.\n *\n * @param type The type to get a parser for.\n * @return The parser.\n */\nexport const getParser = (type: string): Parser => {\n  const parsers: { [key: string]: Parser } = {\n    address,\n    array,\n    bool,\n    bytes,\n    fixedBytes,\n    function: fn,\n    number,\n    string,\n    tuple\n  };\n\n  if (parsers[type]) {\n    return parsers[type];\n  }\n\n  const parser = Object.values(parsers).find((parser) => parser.isType?.(type));\n  if (parser) {\n    return parser;\n  }\n\n  throw new Error(`Type \"${type}\" is not supported`);\n};\n\n/**\n * Check if the specified parser is dynamic, for the provided types. This is primarily used for parsing tuples, where\n * a tuple can be dynamic based on the types. For other parsers, it will simply use the set `isDynamic` value.\n *\n * @param parser The parser to check.\n * @param type The type to check the parser with.\n * @return Whether the parser is dynamic.\n */\nexport const isDynamicParser = (parser: Parser, type: string): boolean => {\n  const isDynamic = parser.isDynamic;\n  if (typeof isDynamic === 'function') {\n    return isDynamic(type);\n  }\n\n  return isDynamic;\n};\n\ntype UpdateFunction = (buffer: Uint8Array) => Uint8Array;\n\ninterface PackState {\n  staticBuffer: Uint8Array;\n  dynamicBuffer: Uint8Array;\n  functions: UpdateFunction[];\n}\n\n/**\n * Pack the provided values in a buffer, encoded with the specified types. If a buffer is specified, the resulting value\n * will be concatenated with the buffer.\n *\n * @param types The types to use for encoding.\n * @param values The values to encode.\n * @param [buffer] The buffer to concatenate with.\n * @return The resulting encoded buffer.\n */\nexport const pack = (types: string[], values: unknown[], buffer: Uint8Array = new Uint8Array()): Uint8Array => {\n  if (types.length !== values.length) {\n    throw new Error('The length of the types and values must be equal');\n  }\n\n  const { staticBuffer, dynamicBuffer, functions } = types.reduce<PackState>(\n    ({ staticBuffer, dynamicBuffer, functions }, type, index) => {\n      const parser = getParser(type);\n      const value = values[index];\n\n      if (!isDynamicParser(parser, type)) {\n        return {\n          staticBuffer: parser.encode({ buffer: staticBuffer, value, type }),\n          dynamicBuffer,\n          functions\n        };\n      }\n\n      const offset = dynamicBuffer.length;\n      const staticOffset = staticBuffer.length;\n\n      const newStaticBuffer = concat([staticBuffer, new Uint8Array(32).fill(0)]);\n      const newDynamicBuffer = parser.encode({ buffer: dynamicBuffer, value, type });\n\n      const fn = (oldBuffer: Uint8Array): Uint8Array => {\n        return concat([\n          oldBuffer.subarray(0, staticOffset),\n          toBuffer(oldBuffer.length + offset),\n          oldBuffer.subarray(staticOffset + 32)\n        ]);\n      };\n\n      return {\n        staticBuffer: newStaticBuffer,\n        dynamicBuffer: newDynamicBuffer,\n        functions: [...functions, fn]\n      };\n    },\n    { staticBuffer: new Uint8Array(), dynamicBuffer: new Uint8Array(), functions: [] }\n  );\n\n  const updatedBuffer = functions.reduce<Uint8Array>((target, update) => update(target), staticBuffer);\n\n  return concat([buffer, updatedBuffer, dynamicBuffer]);\n};\n\nexport const unpack = (types: string[], buffer: Uint8Array): unknown[] => {\n  const iterator = iterate(buffer);\n\n  return types.map((type) => {\n    const {\n      value: { value, skip },\n      done\n    } = iterator.next();\n    if (done) {\n      throw new Error('Element is out of range');\n    }\n\n    const parser = getParser(type);\n    const isDynamic = isDynamicParser(parser, type);\n\n    if (isDynamic) {\n      const pointer = Number(toNumber(value.subarray(0, 32)));\n      const target = buffer.subarray(pointer);\n\n      return parser.decode({ type, value: target, skip });\n    }\n\n    return parser.decode({ type, value, skip });\n  });\n};\n"],"file":"packer.js"}