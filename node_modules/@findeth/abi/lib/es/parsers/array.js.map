{"version":3,"sources":["../../../src/parsers/array.ts"],"names":["pack","unpack","concat","toBuffer","toNumber","ARRAY_REGEX","getArrayType","type","match","Error","array","isDynamic","isType","test","encode","buffer","value","arrayType","arrayLength","length","Array","fill","decode","Number","subarray"],"mappings":"AAAA,SAASA,IAAT,EAAeC,MAAf,QAA6B,WAA7B;AAEA,SAASC,MAAT,EAAiBC,QAAjB,EAA2BC,QAA3B,QAA2C,UAA3C;AAGA,MAAMC,WAAW,GAAG,WAApB;AAQA,OAAO,MAAMC,YAAY,GAAIC,IAAD,IAA0B;AACpD,QAAMC,KAAK,GAAGD,IAAI,CAACC,KAAL,CAAWH,WAAX,CAAd;;AACA,MAAIG,KAAJ,EAAW;AACT,WAAOA,KAAK,CAAC,CAAD,CAAZ;AACD;;AAED,QAAM,IAAIC,KAAJ,CAAU,2BAAV,CAAN;AACD,CAPM;AASP,OAAO,MAAMC,KAAwB,GAAG;AACtCC,EAAAA,SAAS,EAAE,IAD2B;;AAStCC,EAAAA,MAAM,CAACL,IAAD,EAAwB;AAC5B,WAAOF,WAAW,CAACQ,IAAZ,CAAiBN,IAAjB,CAAP;AACD,GAXqC;;AAatCO,EAAAA,MAAM,CAAC;AAAEP,IAAAA,IAAF;AAAQQ,IAAAA,MAAR;AAAgBC,IAAAA;AAAhB,GAAD,EAAsC;AAC1C,UAAMC,SAAS,GAAGX,YAAY,CAACC,IAAD,CAA9B;AACA,UAAMW,WAAW,GAAGf,QAAQ,CAACa,KAAK,CAACG,MAAP,CAA5B;AAEA,WAAOnB,IAAI,CAAC,IAAIoB,KAAJ,CAAUJ,KAAK,CAACG,MAAhB,EAAwBE,IAAxB,CAA6BJ,SAA7B,CAAD,EAA0CD,KAA1C,EAAiDd,MAAM,CAAC,CAACa,MAAD,EAASG,WAAT,CAAD,CAAvD,CAAX;AACD,GAlBqC;;AAoBtCI,EAAAA,MAAM,CAAC;AAAEf,IAAAA,IAAF;AAAQS,IAAAA;AAAR,GAAD,EAAyC;AAC7C,UAAMC,SAAS,GAAGX,YAAY,CAACC,IAAD,CAA9B;AACA,UAAMW,WAAW,GAAGK,MAAM,CAACnB,QAAQ,CAACY,KAAK,CAACQ,QAAN,CAAe,CAAf,EAAkB,EAAlB,CAAD,CAAT,CAA1B;AAEA,WAAOvB,MAAM,CAAC,IAAImB,KAAJ,CAAUF,WAAV,EAAuBG,IAAvB,CAA4BJ,SAA5B,CAAD,EAAyCD,KAAK,CAACQ,QAAN,CAAe,EAAf,CAAzC,CAAb;AACD;;AAzBqC,CAAjC","sourcesContent":["import { pack, unpack } from '../packer';\nimport { DecodeArgs, Parser } from '../types';\nimport { concat, toBuffer, toNumber } from '../utils';\n\n// TODO: Add support for fixed length arrays\nconst ARRAY_REGEX = /^(.*)\\[]$/;\n\n/**\n * Get the type of the array.\n *\n * @param type The type to get the array type for.\n * @return The array type.\n */\nexport const getArrayType = (type: string): string => {\n  const match = type.match(ARRAY_REGEX);\n  if (match) {\n    return match[1];\n  }\n\n  throw new Error('Type is not an array type');\n};\n\nexport const array: Parser<unknown[]> = {\n  isDynamic: true,\n\n  /**\n   * Check if a type is an array type.\n   *\n   * @param type The type to check.\n   * @return Whether the type is a array type.\n   */\n  isType(type: string): boolean {\n    return ARRAY_REGEX.test(type);\n  },\n\n  encode({ type, buffer, value }): Uint8Array {\n    const arrayType = getArrayType(type);\n    const arrayLength = toBuffer(value.length);\n\n    return pack(new Array(value.length).fill(arrayType), value, concat([buffer, arrayLength]));\n  },\n\n  decode({ type, value }: DecodeArgs): unknown[] {\n    const arrayType = getArrayType(type);\n    const arrayLength = Number(toNumber(value.subarray(0, 32)));\n\n    return unpack(new Array(arrayLength).fill(arrayType), value.subarray(32));\n  }\n};\n"],"file":"array.js"}