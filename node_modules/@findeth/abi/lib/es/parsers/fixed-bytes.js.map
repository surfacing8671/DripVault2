{"version":3,"sources":["../../../src/parsers/fixed-bytes.ts"],"names":["addPadding","concat","toBuffer","BYTES_REGEX","getByteLength","type","bytes","match","length","Number","Error","fixedBytes","isDynamic","isType","test","encode","buffer","value","bufferValue","decode","slice"],"mappings":"AACA,SAASA,UAAT,EAAqBC,MAArB,EAA6BC,QAA7B,QAA6C,UAA7C;AAEA,MAAMC,WAAW,GAAG,qBAApB;AASA,OAAO,MAAMC,aAAa,GAAIC,IAAD,IAA0B;AAAA;;AACrD,QAAMC,KAAK,kBAAGD,IAAI,CAACE,KAAL,CAAWJ,WAAX,CAAH,gDAAG,YAA0B,CAA1B,CAAd;;AAEA,MAAIG,KAAJ,EAAW;AACT,UAAME,MAAM,GAAGC,MAAM,CAACH,KAAD,CAArB;;AACA,QAAIE,MAAM,IAAI,CAAV,IAAeA,MAAM,GAAG,EAA5B,EAAgC;AAC9B,YAAM,IAAIE,KAAJ,CAAU,sCAAV,CAAN;AACD;;AAED,WAAOF,MAAP;AACD;;AAED,QAAM,IAAIE,KAAJ,CAAU,yBAAV,CAAN;AACD,CAbM;AAeP,OAAO,MAAMC,UAAyC,GAAG;AACvDC,EAAAA,SAAS,EAAE,KAD4C;;AASvDC,EAAAA,MAAM,CAACR,IAAD,EAAwB;AAC5B,WAAOF,WAAW,CAACW,IAAZ,CAAiBT,IAAjB,CAAP;AACD,GAXsD;;AAavDU,EAAAA,MAAM,CAAC;AAAEV,IAAAA,IAAF;AAAQW,IAAAA,MAAR;AAAgBC,IAAAA;AAAhB,GAAD,EAAsC;AAC1C,UAAMT,MAAM,GAAGJ,aAAa,CAACC,IAAD,CAA5B;AACA,UAAMa,WAAW,GAAGhB,QAAQ,CAACe,KAAD,CAA5B;;AAEA,QAAIC,WAAW,CAACV,MAAZ,KAAuBA,MAA3B,EAAmC;AACjC,YAAM,IAAIE,KAAJ,CAAW,uCAAsCF,MAAO,SAAQU,WAAW,CAACV,MAAO,EAAnF,CAAN;AACD;;AAED,WAAOP,MAAM,CAAC,CAACe,MAAD,EAAShB,UAAU,CAACkB,WAAD,CAAnB,CAAD,CAAb;AACD,GAtBsD;;AAwBvDC,EAAAA,MAAM,CAAC;AAAEd,IAAAA,IAAF;AAAQY,IAAAA;AAAR,GAAD,EAA0C;AAC9C,UAAMT,MAAM,GAAGJ,aAAa,CAACC,IAAD,CAA5B;AACA,WAAOY,KAAK,CAACG,KAAN,CAAY,CAAZ,EAAeZ,MAAf,CAAP;AACD;;AA3BsD,CAAlD","sourcesContent":["import { BytesLike, DecodeArgs, Parser } from '../types';\nimport { addPadding, concat, toBuffer } from '../utils';\n\nconst BYTES_REGEX = /^bytes([0-9]{1,2})$/;\n\n/**\n * Get the length of the specified type. If a length is not specified, or if the length is out of range (0 < n <= 32),\n * this will throw an error.\n *\n * @param type The type to get the length for.\n * @return The byte length of the type.\n */\nexport const getByteLength = (type: string): number => {\n  const bytes = type.match(BYTES_REGEX)?.[1];\n\n  if (bytes) {\n    const length = Number(bytes);\n    if (length <= 0 || length > 32) {\n      throw new Error('Invalid type: length is out of range');\n    }\n\n    return length;\n  }\n\n  throw new Error('Invalid type: no length');\n};\n\nexport const fixedBytes: Parser<BytesLike, Uint8Array> = {\n  isDynamic: false,\n\n  /**\n   * Check if a type is a fixed bytes type.\n   *\n   * @param type The type to check.\n   * @return Whether the type is a fixed bytes type.\n   */\n  isType(type: string): boolean {\n    return BYTES_REGEX.test(type);\n  },\n\n  encode({ type, buffer, value }): Uint8Array {\n    const length = getByteLength(type);\n    const bufferValue = toBuffer(value);\n\n    if (bufferValue.length !== length) {\n      throw new Error(`Buffer has invalid length, expected ${length}, got ${bufferValue.length}`);\n    }\n\n    return concat([buffer, addPadding(bufferValue)]);\n  },\n\n  decode({ type, value }: DecodeArgs): Uint8Array {\n    const length = getByteLength(type);\n    return value.slice(0, length);\n  }\n};\n"],"file":"fixed-bytes.js"}