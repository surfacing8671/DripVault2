{"version":3,"sources":["../../../src/parsers/tuple.ts"],"names":["getParser","isDynamicParser","pack","unpack","TUPLE_REGEX","getTupleElements","type","slice","split","map","trim","tuple","isDynamic","elements","some","element","parser","isType","test","encode","buffer","value","decode","skip","length"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,eAApB,EAAqCC,IAArC,EAA2CC,MAA3C,QAAyD,WAAzD;AAGA,MAAMC,WAAW,GAAG,YAApB;AAQA,OAAO,MAAMC,gBAAgB,GAAIC,IAAD,IAA4B;AAC1D,SAAOA,IAAI,CACRC,KADI,CACE,CADF,EACK,CAAC,CADN,EAEJC,KAFI,CAEE,GAFF,EAGJC,GAHI,CAGCH,IAAD,IAAUA,IAAI,CAACI,IAAL,EAHV,CAAP;AAID,CALM;AAOP,OAAO,MAAMC,KAAwB,GAAG;AAOtCC,EAAAA,SAAS,CAACN,IAAD,EAAwB;AAC/B,UAAMO,QAAQ,GAAGR,gBAAgB,CAACC,IAAD,CAAjC;AACA,WAAOO,QAAQ,CAACC,IAAT,CAAeC,OAAD,IAAa;AAChC,YAAMC,MAAM,GAAGhB,SAAS,CAACe,OAAD,CAAxB;AACA,aAAOd,eAAe,CAACe,MAAD,EAASD,OAAT,CAAtB;AACD,KAHM,CAAP;AAID,GAbqC;;AAqBtCE,EAAAA,MAAM,CAACX,IAAD,EAAwB;AAC5B,WAAOF,WAAW,CAACc,IAAZ,CAAiBZ,IAAjB,CAAP;AACD,GAvBqC;;AAyBtCa,EAAAA,MAAM,CAAC;AAAEb,IAAAA,IAAF;AAAQc,IAAAA,MAAR;AAAgBC,IAAAA;AAAhB,GAAD,EAAsC;AAC1C,UAAMR,QAAQ,GAAGR,gBAAgB,CAACC,IAAD,CAAjC;AACA,WAAOJ,IAAI,CAACW,QAAD,EAAWQ,KAAX,EAAkBD,MAAlB,CAAX;AACD,GA5BqC;;AA8BtCE,EAAAA,MAAM,CAAC;AAAEhB,IAAAA,IAAF;AAAQe,IAAAA,KAAR;AAAeE,IAAAA;AAAf,GAAD,EAA+C;AACnD,UAAMV,QAAQ,GAAGR,gBAAgB,CAACC,IAAD,CAAjC;AACA,UAAMkB,MAAM,GAAGX,QAAQ,CAACW,MAAT,GAAkB,EAAlB,GAAuB,EAAtC;;AAEA,QAAI,CAACvB,eAAe,CAAC,IAAD,EAAOK,IAAP,CAApB,EAAkC;AAChCiB,MAAAA,IAAI,CAACC,MAAD,CAAJ;AACD;;AAED,WAAOrB,MAAM,CAACU,QAAD,EAAWQ,KAAX,CAAb;AACD;;AAvCqC,CAAjC","sourcesContent":["import { getParser, isDynamicParser, pack, unpack } from '../packer';\nimport { DecodeArgs, Parser } from '../types';\n\nconst TUPLE_REGEX = /^\\((.*)\\)$/;\n\n/**\n * Get elements from a tuple type.\n *\n * @param type The tuple type to get the types for.\n * @return The elements of the tuple as string array.\n */\nexport const getTupleElements = (type: string): string[] => {\n  return type\n    .slice(1, -1)\n    .split(',')\n    .map((type) => type.trim());\n};\n\nexport const tuple: Parser<unknown[]> = {\n  /**\n   * Check if the tuple is dynamic. Tuples are dynamic if one or more elements of the tuple are dynamic.\n   *\n   * @param type The type to check.\n   * @return Whether the tuple is dynamic.\n   */\n  isDynamic(type: string): boolean {\n    const elements = getTupleElements(type);\n    return elements.some((element) => {\n      const parser = getParser(element);\n      return isDynamicParser(parser, element);\n    });\n  },\n\n  /**\n   * Check if a type is an tuple type.\n   *\n   * @param type The type to check.\n   * @return Whether the type is a tuple type.\n   */\n  isType(type: string): boolean {\n    return TUPLE_REGEX.test(type);\n  },\n\n  encode({ type, buffer, value }): Uint8Array {\n    const elements = getTupleElements(type);\n    return pack(elements, value, buffer);\n  },\n\n  decode({ type, value, skip }: DecodeArgs): unknown[] {\n    const elements = getTupleElements(type);\n    const length = elements.length * 32 - 32;\n\n    if (!isDynamicParser(this, type)) {\n      skip(length);\n    }\n\n    return unpack(elements, value);\n  }\n};\n"],"file":"tuple.js"}