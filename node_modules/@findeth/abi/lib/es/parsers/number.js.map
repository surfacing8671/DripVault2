{"version":3,"sources":["../../../src/parsers/number.ts"],"names":["concat","fromTwosComplement","toBuffer","toNumber","toTwosComplement","NUMBER_REGEX","isSigned","type","startsWith","asNumber","value","BigInt","number","isDynamic","isType","test","encode","buffer","decode","slice"],"mappings":"AACA,SAASA,MAAT,EAAiBC,kBAAjB,EAAqCC,QAArC,EAA+CC,QAA/C,EAAyDC,gBAAzD,QAAiF,UAAjF;AAEA,MAAMC,YAAY,GAAG,kBAArB;AAQA,OAAO,MAAMC,QAAQ,GAAIC,IAAD,IAA2B;AACjD,SAAO,CAACA,IAAI,CAACC,UAAL,CAAgB,GAAhB,CAAR;AACD,CAFM;AAUP,OAAO,MAAMC,QAAQ,GAAIC,KAAD,IAA+B;AACrD,MAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC7B,WAAOA,KAAP;AACD;;AAED,SAAOC,MAAM,CAACD,KAAD,CAAb;AACD,CANM;AAQP,OAAO,MAAME,MAAkC,GAAG;AAChDC,EAAAA,SAAS,EAAE,KADqC;;AAQhDC,EAAAA,MAAM,CAACP,IAAD,EAAwB;AAC5B,WAAOF,YAAY,CAACU,IAAb,CAAkBR,IAAlB,CAAP;AACD,GAV+C;;AAYhDS,EAAAA,MAAM,CAAC;AAAET,IAAAA,IAAF;AAAQU,IAAAA,MAAR;AAAgBP,IAAAA;AAAhB,GAAD,EAAsC;AAC1C,UAAME,MAAM,GAAGH,QAAQ,CAACC,KAAD,CAAvB;;AAEA,QAAIJ,QAAQ,CAACC,IAAD,CAAZ,EAAoB;AAClB,aAAOP,MAAM,CAAC,CAACiB,MAAD,EAASb,gBAAgB,CAACQ,MAAD,EAAS,EAAT,CAAzB,CAAD,CAAb;AACD;;AAED,WAAOZ,MAAM,CAAC,CAACiB,MAAD,EAASf,QAAQ,CAACU,MAAD,CAAjB,CAAD,CAAb;AACD,GApB+C;;AAsBhDM,EAAAA,MAAM,CAAC;AAAEX,IAAAA,IAAF;AAAQG,IAAAA;AAAR,GAAD,EAAsC;AAC1C,UAAMO,MAAM,GAAGP,KAAK,CAACS,KAAN,CAAY,CAAZ,EAAe,EAAf,CAAf;;AACA,QAAIb,QAAQ,CAACC,IAAD,CAAZ,EAAoB;AAClB,aAAON,kBAAkB,CAACgB,MAAD,CAAzB;AACD;;AAED,WAAOd,QAAQ,CAACc,MAAD,CAAf;AACD;;AA7B+C,CAA3C","sourcesContent":["import { DecodeArgs, NumberLike, Parser } from '../types';\nimport { concat, fromTwosComplement, toBuffer, toNumber, toTwosComplement } from '../utils';\n\nconst NUMBER_REGEX = /^u?int([0-9]*)?$/;\n\n/**\n * Check if a number type is signed.\n *\n * @param type The type to check.\n * @return Whether the type is signed.\n */\nexport const isSigned = (type: string): boolean => {\n  return !type.startsWith('u');\n};\n\n/**\n * Get a number-like value as bigint.\n *\n * @param value The number-like value to parse.\n * @return The value parsed as bigint.\n */\nexport const asNumber = (value: NumberLike): bigint => {\n  if (typeof value === 'bigint') {\n    return value;\n  }\n\n  return BigInt(value);\n};\n\nexport const number: Parser<NumberLike, bigint> = {\n  isDynamic: false,\n\n  /**\n   * Check if a type is a number type.\n   *\n   * @return Whether the type is a number type.\n   */\n  isType(type: string): boolean {\n    return NUMBER_REGEX.test(type);\n  },\n\n  encode({ type, buffer, value }): Uint8Array {\n    const number = asNumber(value);\n\n    if (isSigned(type)) {\n      return concat([buffer, toTwosComplement(number, 32)]);\n    }\n\n    return concat([buffer, toBuffer(number)]);\n  },\n\n  decode({ type, value }: DecodeArgs): bigint {\n    const buffer = value.slice(0, 32);\n    if (isSigned(type)) {\n      return fromTwosComplement(buffer);\n    }\n\n    return toNumber(buffer);\n  }\n};\n"],"file":"number.js"}